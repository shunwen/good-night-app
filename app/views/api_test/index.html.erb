<% content_for :title, "API Test" %>

<div class="container">
  <h1>API Test</h1>
  
  <div class="description">
    <p>Welcome to the API testing interface! Follow these steps for best results:</p>
    <ol>
      <li><strong>Set up test data:</strong> Click "Setup Complete Test Data" below to create 1,000 users with follow relationships and 300,000 sleep records. <em><strong>Warning:</strong> This will clear all existing database data and replace it with fresh test data.</em></li>
      <li><strong>Authenticate:</strong> Use the Auth section to impersonate one of the created users (try user ID 1-1000)</li>
      <li><strong>Test endpoints:</strong> Use the endpoint testing interfaces to interact with the API</li>
      <li><strong>Review history:</strong> Monitor your test results in the Test History section</li>
    </ol>
  </div>

  <div class="section">
    <h2>Test Data Setup</h2>
    <div class="test-data-actions">
      <div class="test-data-form">
        <div class="form-row">
          <label for="user-count">Users:</label>
          <input type="number" id="user-count" value="100" min="1" max="10000">
          
          <label for="follows-per-user">Follows per user:</label>
          <input type="number" id="follows-per-user" value="50" min="0" max="1000">
          
          <label for="sleeps-per-user">Sleeps per user:</label>
          <input type="number" id="sleeps-per-user" value="300" min="0" max="1000">
        </div>
        <button onclick="createBulkTestData()" class="bulk-create-btn">
          Setup Test Data
        </button>
      </div>
      <div id="bulk-create-result" class="result hidden">
        <div class="tabs">
          <button class="tab active" onclick="showTab(this, 'bulk-summary')">Summary</button>
          <button class="tab" onclick="showTab(this, 'bulk-progress')">Progress</button>
        </div>
        <div id="bulk-summary" class="tab-content active">
          <pre class="content"></pre>
        </div>
        <div id="bulk-progress" class="tab-content">
          <pre class="content"></pre>
        </div>
      </div>
    </div>
  </div>

  <div class="section">
    <h2>Auth</h2>
    <div id="auth-status">
      <%= render partial: "auth_status", locals: { user: @user, user_id: cookies[:user_id], sleeps_count: @sleeps_count, following_count: @following_count, status: @status } %>
    </div>
    <form id="session-form">
      <label for="user_id">User ID:</label>
      <input type="number" id="user_id" name="user_id" value="<%= @default_user_id %>" min="1" placeholder="<%= @default_user_id ? "User ID (e.g., #{@default_user_id})" : "User ID" %>">
      <button type="submit">Sign In</button>
    </form>
    <button id="sign-out-btn">Sign Out</button>
  </div>

  <div class="section">
    <h2>Test History</h2>
    <div id="test-history">
      <p>No tests run yet</p>
    </div>
  </div>

  <%= render 'endpoints' %>
</div>

<script>
let testHistory = [];

// Handle session authentication
document.addEventListener('DOMContentLoaded', function() {
  const sessionForm = document.getElementById('session-form');
  const signOutBtn = document.getElementById('sign-out-btn');
  
  // Check if already signed in when page loads
  updateAuthStatus();
  
  sessionForm.addEventListener('submit', async function(e) {
    e.preventDefault();
    const userId = document.getElementById('user_id').value;
    
    try {
      const response = await fetch('/session', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ user_id: userId })
      });
      
      if (response.ok) {
        // Fetch user details via users#show
        await updateAuthStatus();
      } else {
        showAuthStatus('not_found', null, userId);
      }
    } catch (error) {
      showAuthStatus('error', null, userId);
    }
  });
  
  signOutBtn.addEventListener('click', async function() {
    try {
      const response = await fetch('/session', {
        method: 'DELETE',
        headers: {
          'Accept': 'application/json'
        }
      });
      
      if (response.ok) {
        showAuthStatus('cleared', null, null);
      }
    } catch (error) {
      console.error('Sign out error:', error);
    }
  });
});

async function updateAuthStatus() {
  try {
    const response = await fetch('/users/current.json');
    if (response.ok) {
      const userData = await response.json();
      showAuthStatus('success', userData, userData.id);
    } else {
      showAuthStatus('cleared', null, null);
    }
  } catch (error) {
    showAuthStatus('cleared', null, null);
  }
}

function showAuthStatus(status, user, userId) {
  const authStatusDiv = document.getElementById('auth-status');
  let html = '';
  
  switch (status) {
    case 'success':
      html = `
        <div class="auth-status success">
          <p><strong>Signed in as User #${userId}</strong></p>
          <div class="user-details">
            <p><strong>Name:</strong> ${user.name}</p>
            <p><strong>Sleep Records:</strong> ${user.sleeps_count || 0}</p>
            <p><strong>Following:</strong> ${user.following_count || 0} users</p>
            <p><strong>Followers:</strong> ${user.followers_count || 0} users</p>
            <p><strong>Created:</strong> ${new Date(user.created_at).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
          </div>
        </div>`;
      break;
    case 'not_found':
      html = `
        <div class="auth-status warning">
          <p><strong>User #${userId}</strong></p>
          <p><em>User not found</em></p>
        </div>`;
      break;
    case 'error':
      html = `
        <div class="auth-status warning">
          <p><strong>Error signing in</strong></p>
          <p><em>Please try again</em></p>
        </div>`;
      break;
    case 'cleared':
    default:
      html = `
        <div class="auth-status">
          <p>Not authenticated</p>
        </div>`;
      break;
  }
  
  authStatusDiv.innerHTML = html;
}

function showTab(button, tabId) {
  // Get the parent result container
  const resultContainer = button.closest('.result');
  
  // Hide all tab contents and remove active from buttons
  const allTabs = resultContainer.querySelectorAll('.tab-content');
  const allButtons = resultContainer.querySelectorAll('.tab');
  
  allTabs.forEach(tab => tab.classList.remove('active'));
  allButtons.forEach(btn => btn.classList.remove('active'));
  
  // Show selected tab and mark button as active
  document.getElementById(tabId).classList.add('active');
  button.classList.add('active');
}

function addToTestHistory(test) {
  testHistory.unshift(test); // Add to beginning of array
  if (testHistory.length > 20) {
    testHistory = testHistory.slice(0, 20); // Keep only last 20 tests
  }
  updateTestHistoryDisplay();
}

function updateTestHistoryDisplay() {
  const historyDiv = document.getElementById('test-history');
  
  if (testHistory.length === 0) {
    historyDiv.innerHTML = '<p>No tests run yet</p>';
    return;
  }
  
  const historyHtml = testHistory.map(test => {
    const statusClass = test.success ? 'success' : 'error';
    const timeStr = new Date(test.timestamp).toLocaleTimeString();
    return `<div class="test-item ${statusClass}">
      <span class="test-time">${timeStr}</span>
      <span class="test-method">${test.method}</span>
      <span class="test-url">${test.url}</span>
      <span class="test-status">${test.status}</span>
      <span class="test-time-taken">${test.responseTime}ms</span>
    </div>`;
  }).join('');
  
  historyDiv.innerHTML = historyHtml;
}

async function testEndpoint(method, url, payload) {
  const startTime = performance.now();
  
  // Find result containers - look for the button that was clicked and find its endpoint container
  const button = event.target;
  const endpointDiv = button.closest('.endpoint');
  const resultDiv = endpointDiv.querySelector('.result');
  const resultIndex = resultDiv.id.split('-')[1];
  const summaryContent = resultDiv.querySelector(`#summary-${resultIndex} .content`);
  const requestContent = resultDiv.querySelector(`#request-${resultIndex} .content`);
  const responseContent = resultDiv.querySelector(`#response-${resultIndex} .content`);
  
  try {
    const options = {
      method: method,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    };
    
    if (payload && (method === 'POST' || method === 'PATCH' || method === 'DELETE')) {
      const testPayload = JSON.parse(JSON.stringify(payload)); // Deep copy
      
      // Generate unique user name for create operations
      if (testPayload.user && testPayload.user.name) {
        const randomSuffix = Math.random().toString(36).substring(2, 8);
        testPayload.user.name = `Test User ${randomSuffix}`; // Always use base name
      }
      
      // Generate random followed_id for follow operations
      if (testPayload.followed_id) {
        testPayload.followed_id = Math.floor(Math.random() * 1000) + 1; // Random user ID between 1-1000
      }
      
      // Generate random date within past year for sleep records
      if (testPayload.sleep && testPayload.sleep.started_at_raw) {
        const daysAgo = Math.floor(Math.random() * 365); // Random day in past year
        const randomDate = new Date();
        randomDate.setDate(randomDate.getDate() - daysAgo);
        
        // Random sleep start time between 9 PM and 1 AM
        const startHour = 21 + Math.floor(Math.random() * 4); // 21, 22, 23, or 0 (midnight)
        const startMinute = Math.floor(Math.random() * 60);
        
        const startDate = new Date(randomDate);
        startDate.setHours(startHour, startMinute, 0, 0);
        
        // Sleep duration between 6-10 hours
        const sleepDurationHours = 6 + Math.floor(Math.random() * 4);
        const sleepDurationMinutes = Math.floor(Math.random() * 60);
        
        const endDate = new Date(startDate);
        endDate.setHours(endDate.getHours() + sleepDurationHours, endDate.getMinutes() + sleepDurationMinutes);
        
        // Format dates as strings
        const formatDate = (date) => {
          return date.getFullYear() + '-' + 
                 String(date.getMonth() + 1).padStart(2, '0') + '-' + 
                 String(date.getDate()).padStart(2, '0') + ' ' +
                 String(date.getHours()).padStart(2, '0') + ':' +
                 String(date.getMinutes()).padStart(2, '0') + ':00 PST';
        };
        
        testPayload.sleep.started_at_raw = formatDate(startDate);
        testPayload.sleep.stopped_at_raw = formatDate(endDate);
      }
      
      options.body = JSON.stringify(testPayload);
    }
    
    // Show raw request
    let requestText = `${method} ${url} HTTP/1.1
Content-Type: application/json
Accept: application/json`;
    
    if (options.body) {
      requestText += `\nContent-Length: ${options.body.length}\n\n${options.body}`;
    }
    
    requestContent.textContent = requestText;
    
    const response = await fetch(url, options);
    const endTime = performance.now();
    const responseTime = Math.round(endTime - startTime);
    
    let result = '';
    let rawResponseBody = '';
    const contentType = response.headers.get('content-type');
    
    if (contentType && contentType.includes('application/json')) {
      const data = await response.json();
      result = JSON.stringify(data, null, 2);
      rawResponseBody = result;
    } else {
      result = await response.text();
      rawResponseBody = result;
    }
    
    // Show raw response
    let responseText = `HTTP/1.1 ${response.status} ${response.statusText}`;
    for (const [key, value] of response.headers.entries()) {
      responseText += `\n${key}: ${value}`;
    }
    responseText += `\n\n${rawResponseBody}`;
    
    responseContent.textContent = responseText;
    
    // Add to test history
    addToTestHistory({
      timestamp: Date.now(),
      method: method,
      url: url,
      status: response.status,
      responseTime: responseTime,
      success: response.ok
    });
    
    // Display summary
    summaryContent.innerHTML = `Status: ${response.status} ${response.statusText}
Response Time: ${responseTime}ms
Content-Type: ${contentType}

${result}`;
    
    resultDiv.classList.remove('hidden');
    resultDiv.classList.remove('success', 'error');
    resultDiv.classList.add(response.ok ? 'success' : 'error');
    
  } catch (error) {
    const endTime = performance.now();
    const responseTime = Math.round(endTime - startTime);
    
    // Show error in raw response
    responseContent.textContent = `Error: ${error.message}`;
    
    // Add error to test history
    addToTestHistory({
      timestamp: Date.now(),
      method: method,
      url: url,
      status: 'Error',
      responseTime: responseTime,
      success: false
    });
    
    // Display error summary
    summaryContent.innerHTML = `Error: ${error.message}
Response Time: ${responseTime}ms`;
    
    resultDiv.classList.remove('hidden');
    resultDiv.classList.remove('success', 'error');
    resultDiv.classList.add('error');
  }
}

async function performanceTest(method, url, payload, iterations) {
  const results = [];
  const button = document.querySelector(`button[onclick*="performanceTest"][onclick*="${method}"][onclick*="${url}"]`);
  const originalText = button.textContent;
  
  for (let i = 0; i < iterations; i++) {
    button.textContent = `Testing... (${i + 1}/${iterations})`;
    const startTime = performance.now();
    
    try {
      const options = {
        method: method,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        }
      };
      
      if (payload && (method === 'POST' || method === 'PATCH' || method === 'DELETE')) {
        // Add randomization for create operations to avoid conflicts
        if (payload.user && payload.user.name) {
          const testPayload = JSON.parse(JSON.stringify(payload)); // Deep copy
          const randomSuffix = Math.random().toString(36).substring(2, 8);
          testPayload.user.name = `Test User ${randomSuffix}`; // Always use base name
          options.body = JSON.stringify(testPayload);
        } else {
          options.body = JSON.stringify(payload);
        }
      }
      
      const response = await fetch(url, options);
      const endTime = performance.now();
      const responseTime = Math.round(endTime - startTime);
      
      results.push({
        iteration: i + 1,
        status: response.status,
        responseTime: responseTime,
        success: response.ok
      });
      
      // Add each test to history
      addToTestHistory({
        timestamp: Date.now(),
        method: method,
        url: url,
        status: response.status,
        responseTime: responseTime,
        success: response.ok
      });
      
    } catch (error) {
      const endTime = performance.now();
      const responseTime = Math.round(endTime - startTime);
      
      results.push({
        iteration: i + 1,
        status: 'Error',
        responseTime: responseTime,
        success: false,
        error: error.message
      });
      
      // Add error to history
      addToTestHistory({
        timestamp: Date.now(),
        method: method,
        url: url,
        status: 'Error',
        responseTime: responseTime,
        success: false
      });
    }
  }
  
  button.textContent = originalText;
  
  // Calculate performance metrics
  const successfulResults = results.filter(r => r.success);
  const avgResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / results.length;
  const minResponseTime = Math.min(...results.map(r => r.responseTime));
  const maxResponseTime = Math.max(...results.map(r => r.responseTime));
  const successRate = (successfulResults.length / results.length) * 100;
  
  // Display performance results
  const resultDiv = button.closest('.endpoint').querySelector('.result');
  const resultContent = resultDiv.querySelector('#summary-' + resultDiv.id.split('-')[1] + ' .content');
  
  resultContent.innerHTML = `Performance Test Results (${iterations} iterations):

Success Rate: ${successRate.toFixed(1)}%
Average Response Time: ${Math.round(avgResponseTime)}ms
Min Response Time: ${minResponseTime}ms
Max Response Time: ${maxResponseTime}ms

Individual Results:
${results.map(r => `#${r.iteration}: ${r.status} - ${r.responseTime}ms${r.error ? ` (${r.error})` : ''}`).join('\n')}`;
  
  resultDiv.classList.remove('hidden');
  resultDiv.classList.remove('success', 'warning', 'error');
  resultDiv.classList.add(successRate > 90 ? 'success' : 'warning');
}

async function createTestData(method, url, payload, count) {
  const results = [];
  const button = document.querySelector(`button[onclick*="createTestData"][onclick*="${method}"][onclick*="${url}"]`);
  const originalText = button.textContent;
  
  for (let i = 0; i < count; i++) {
    button.textContent = `Creating... (${i + 1}/${count})`;
    const startTime = performance.now();
    
    try {
      const options = {
        method: method,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        }
      };
      
      if (payload && (method === 'POST' || method === 'PATCH' || method === 'DELETE')) {
        const testPayload = JSON.parse(JSON.stringify(payload)); // Deep copy
        
        // Generate random date within past year for sleep records
        if (testPayload.sleep && testPayload.sleep.started_at_raw) {
          const daysAgo = Math.floor(Math.random() * 365); // Random day in past year
          const randomDate = new Date();
          randomDate.setDate(randomDate.getDate() - daysAgo);
          
          // Random sleep start time between 9 PM and 1 AM
          const startHour = 21 + Math.floor(Math.random() * 4); // 21, 22, 23, or 0 (midnight)
          const startMinute = Math.floor(Math.random() * 60);
          
          const startDate = new Date(randomDate);
          startDate.setHours(startHour, startMinute, 0, 0);
          
          // Sleep duration between 6-10 hours
          const sleepDurationHours = 6 + Math.floor(Math.random() * 4);
          const sleepDurationMinutes = Math.floor(Math.random() * 60);
          
          const endDate = new Date(startDate);
          endDate.setHours(endDate.getHours() + sleepDurationHours, endDate.getMinutes() + sleepDurationMinutes);
          
          // Format dates as strings
          const formatDate = (date) => {
            return date.getFullYear() + '-' + 
                   String(date.getMonth() + 1).padStart(2, '0') + '-' + 
                   String(date.getDate()).padStart(2, '0') + ' ' +
                   String(date.getHours()).padStart(2, '0') + ':' +
                   String(date.getMinutes()).padStart(2, '0') + ':00 PST';
          };
          
          testPayload.sleep.started_at_raw = formatDate(startDate);
          testPayload.sleep.stopped_at_raw = formatDate(endDate);
        }
        
        options.body = JSON.stringify(testPayload);
      }
      
      const response = await fetch(url, options);
      const endTime = performance.now();
      const responseTime = Math.round(endTime - startTime);
      
      results.push({
        iteration: i + 1,
        status: response.status,
        responseTime: responseTime,
        success: response.ok
      });
      
      // Add each test to history (but only every 10th to avoid flooding)
      if (i % 10 === 0 || i === count - 1) {
        addToTestHistory({
          timestamp: Date.now(),
          method: method,
          url: url,
          status: response.status,
          responseTime: responseTime,
          success: response.ok
        });
      }
      
    } catch (error) {
      const endTime = performance.now();
      const responseTime = Math.round(endTime - startTime);
      
      results.push({
        iteration: i + 1,
        status: 'Error',
        responseTime: responseTime,
        success: false,
        error: error.message
      });
    }
  }
  
  button.textContent = originalText;
  
  // Calculate summary metrics
  const successfulResults = results.filter(r => r.success);
  const avgResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / results.length;
  const successRate = (successfulResults.length / results.length) * 100;
  
  // Display test data creation results
  const resultDiv = button.closest('.endpoint').querySelector('.result');
  const resultContent = resultDiv.querySelector('#summary-' + resultDiv.id.split('-')[1] + ' .content');
  
  resultContent.innerHTML = `Test Data Generation Complete (${count} records):

Success Rate: ${successRate.toFixed(1)}%
Average Response Time: ${Math.round(avgResponseTime)}ms
Records Created: ${successfulResults.length}
Failed: ${results.length - successfulResults.length}

Generated sleep records spanning the past year with random:
- Sleep start times (9 PM - 1 AM)
- Sleep durations (6-10 hours)
- Dates throughout the past 365 days`;
  
  resultDiv.classList.remove('hidden');
  resultDiv.classList.remove('success', 'warning', 'error');
  resultDiv.classList.add(successRate > 90 ? 'success' : 'warning');
}

async function bulkConcurrentCreate(method, url, payload, count) {
  const results = [];
  const button = document.querySelector('.bulk-create-btn');
  const originalText = button.textContent;
  const maxConcurrent = 50; // Limit concurrent requests for users
  
  let completedOperations = 0;
  let startTime = Date.now();
  
  // Show result container and switch to progress tab immediately
  const resultDiv = document.getElementById('bulk-create-result');
  resultDiv.classList.remove('hidden');
  const progressTab = resultDiv.querySelector('.tab:nth-child(2)');
  progressTab.click(); // Switch to progress tab
  
  const progressContent = document.querySelector('#bulk-progress .content');
  
  // Process users with controlled concurrency
  for (let i = 0; i < count; i += maxConcurrent) {
    const batchEnd = Math.min(i + maxConcurrent, count);
    const batchPromises = [];
    
    button.textContent = `Creating users ${i + 1} to ${batchEnd}...`;
    
    // Create users in current batch
    for (let j = i; j < batchEnd; j++) {
      const userPromise = createUserWithSleeps(method, url, payload, j, maxConcurrent);
      batchPromises.push(userPromise);
    }
    
    // Wait for current batch to complete
    const batchResults = await Promise.all(batchPromises);
    results.push(...batchResults.flat());
    completedOperations += (batchEnd - i);
    
    // Update progress
    const progress = Math.round((completedOperations / count) * 100);
    const elapsedTime = Math.round((Date.now() - startTime) / 1000);
    const successfulOps = results.filter(r => r.success).length;
    const failedOps = results.length - successfulOps;
    
    button.textContent = `Progress: ${progress}% (${completedOperations}/${count} users)`;
    
    // Update progress tab with detailed info
    progressContent.textContent = `Test Data Creation Progress

User Creation Progress: ${progress}%
Users Completed: ${completedOperations}/${count}
Total API Operations: ${results.length}

Successful Operations: ${successfulOps}
Failed Operations: ${failedOps}
Success Rate: ${results.length > 0 ? ((successfulOps / results.length) * 100).toFixed(1) : 0}%

Elapsed Time: ${elapsedTime}s
Current Batch: ${i + 1} to ${batchEnd}
Batch Size: ${maxConcurrent} concurrent requests

Status: ${completedOperations === count ? 'COMPLETED' : 'IN PROGRESS...'}`;
    
    // Small delay between batches to prevent overwhelming
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  button.textContent = originalText;
  
  // Calculate summary metrics
  const successfulResults = results.filter(r => r.success);
  const avgResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / results.length;
  const successRate = (successfulResults.length / results.length) * 100;
  const totalTime = Math.round((Date.now() - startTime) / 1000);
  
  // Update final progress
  progressContent.textContent = `Test Data Creation COMPLETED

User Creation Progress: 100%
Users Completed: ${count}/${count}
Total API Operations: ${results.length}

Successful Operations: ${successfulResults.length}
Failed Operations: ${results.length - successfulResults.length}
Success Rate: ${successRate.toFixed(1)}%

Total Time: ${totalTime}s
Average Response Time: ${Math.round(avgResponseTime)}ms

Status: COMPLETED ✓`;
  
  // Display bulk creation results in summary tab
  const resultContent = document.querySelector('#bulk-summary .content');
  
  const usersCreated = payload.user ? count : 0;
  const sleepsCreated = payload.user ? count * 300 : 0;
  
  resultContent.innerHTML = `Bulk Test Data Creation Complete:

${payload.user ? 
`Users Created: ${usersCreated}
Sleep Records Created: ${sleepsCreated}
Total Operations: ${results.length}` :
`Records Created: ${results.length}`}

Success Rate: ${successRate.toFixed(1)}%
Average Response Time: ${Math.round(avgResponseTime)}ms
Failed Operations: ${results.length - successfulResults.length}
Total Time: ${totalTime}s

Created with concurrent batched processing for optimal performance.
Generated random historical sleep data across the past year.`;
  
  resultDiv.classList.remove('success', 'warning', 'error');
  resultDiv.classList.add(successRate > 90 ? 'success' : 'warning');
  
  // Auto-switch back to summary tab after completion
  setTimeout(() => {
    const summaryTab = resultDiv.querySelector('.tab:first-child');
    summaryTab.click();
  }, 2000);
}

async function createUserWithSleeps(method, url, payload, userIndex, maxConcurrent = 50) {
  const results = [];
  
  if (payload.user) {
    // First create the user
    const userResult = await createSingleRecord(method, url, payload, `${userIndex}`);
    results.push(userResult);
    
    if (userResult.success && userResult.userId) {
      // Then create 300 sleep records for this user with higher concurrency
      const sleepCount = 300;
      const sleepBatchSize = 30; // Higher concurrency for sleep records
      
      for (let batch = 0; batch < Math.ceil(sleepCount / sleepBatchSize); batch++) {
        const batchStart = batch * sleepBatchSize;
        const batchEnd = Math.min(batchStart + sleepBatchSize, sleepCount);
        const sleepPromises = [];
        
        for (let i = batchStart; i < batchEnd; i++) {
          const sleepPayload = {
            sleep: {
              started_at_raw: "2024-01-01 22:00:00 PST",
              stopped_at_raw: "2024-01-01 06:00:00 PST"
            }
          };
          
          const sleepPromise = createSingleRecord('POST', '/users/sleeps', sleepPayload, `Sleep-${userIndex}-${i}`, userResult.userId);
          sleepPromises.push(sleepPromise);
        }
        
        const batchResults = await Promise.all(sleepPromises);
        results.push(...batchResults);
        
        // Minimal delay between sleep batches
        if (batch < Math.ceil(sleepCount / sleepBatchSize) - 1) {
          await new Promise(resolve => setTimeout(resolve, 20));
        }
      }
    }
  } else {
    // Just create single record
    const result = await createSingleRecord(method, url, payload, `Record-${userIndex}`);
    results.push(result);
  }
  
  return results;
}

async function createBulkTestData() {
  const button = document.querySelector('.bulk-create-btn');
  const originalText = button.textContent;
  const startTime = Date.now();
  
  // Get parameters from form inputs
  const userCount = parseInt(document.getElementById('user-count').value) || 100;
  const followsPerUser = parseInt(document.getElementById('follows-per-user').value) || 50;
  const sleepsPerUser = parseInt(document.getElementById('sleeps-per-user').value) || 300;
  
  // Show result container and switch to progress tab immediately
  const resultDiv = document.getElementById('bulk-create-result');
  resultDiv.classList.remove('hidden');
  const progressTab = resultDiv.querySelector('.tab:nth-child(2)');
  progressTab.click();
  
  const progressContent = document.querySelector('#bulk-progress .content');
  const summaryContent = document.querySelector('#bulk-summary .content');
  
  try {
    button.textContent = 'Creating test data...';
    
    // Show initial progress with dynamic values
    const totalSleepRecords = userCount * sleepsPerUser;
    const totalFollowRelationships = userCount * followsPerUser;
    
    progressContent.textContent = `Configurable Test Data Setup

Parameters:
- Users: ${userCount.toLocaleString()}
- Follows per user: ${followsPerUser.toLocaleString()}
- Sleeps per user: ${sleepsPerUser.toLocaleString()}

Clearing existing data (users, follows, sleeps)...
Creating ${userCount.toLocaleString()} users + ${totalFollowRelationships.toLocaleString()} follow relationships + ${totalSleepRecords.toLocaleString()} sleep records

Status: PROCESSING...`;
    
    const response = await fetch('/api_test/test_data', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({
        user_count: userCount,
        follows_per_user: followsPerUser,
        sleeps_per_user: sleepsPerUser
      })
    });
    
    const endTime = Date.now();
    const totalTime = (endTime - startTime) / 1000;
    
    if (response.ok) {
      const data = await response.json();
      
      // Update final progress
      progressContent.textContent = `Server-Side Bulk Test Data Creation COMPLETED

Users Created: ${data.users_created}
Sleep Records Created: ${data.sleep_records_created}
Total Time: ${data.total_time_seconds}s

Status: COMPLETED ✓

Created with unique user names and random sleep data across timezones.`;
      
      // Update summary with dynamic values
      const followsPerUserActual = data.follows_created > 0 ? Math.round(data.follows_created / data.users_created) : 0;
      
      summaryContent.innerHTML = `Configurable Test Data Setup Finished:

Users Created: ${data.users_created.toLocaleString()}
Sleep Records Created: ${data.sleep_records_created.toLocaleString()} (${Math.round(data.sleep_records_created / data.users_created)} per user)
Follow Relationships: ${data.follows_created.toLocaleString()} total (${followsPerUserActual} per user)

Parameters Used:
- Users: ${data.parameters.user_count.toLocaleString()}
- Follows per user: ${data.parameters.follows_per_user.toLocaleString()}
- Sleeps per user: ${data.parameters.sleeps_per_user.toLocaleString()}

Server Processing Time: ${data.total_time_seconds}s
Client Request Time: ${totalTime.toFixed(2)}s

✨ Configurable Database Setup:
- Cleared all existing data (users, follows, sleeps)
- Unique user names using SecureRandom
- Configurable follow relationships between users
- Random sleep times across multiple timezones  
- Sleep durations between 5-10 hours
- Historical data spread over past ${Math.round(data.parameters.sleeps_per_user * 1.5)} days
- Database bulk inserts for optimal performance`;
      
      resultDiv.classList.remove('success', 'warning', 'error');
      resultDiv.classList.add('success');
      
      // Add to test history
      addToTestHistory({
        timestamp: Date.now(),
        method: 'POST',
        url: '/api_test/create_test_data',
        status: response.status,
        responseTime: Math.round(totalTime * 1000),
        success: true
      });
      
    } else {
      throw new Error(`Server returned ${response.status}: ${response.statusText}`);
    }
    
  } catch (error) {
    const endTime = Date.now();
    const totalTime = (endTime - startTime) / 1000;
    
    progressContent.textContent = `Server-Side Bulk Test Data Creation FAILED

Error: ${error.message}
Total Time: ${totalTime.toFixed(2)}s

Status: ERROR ✗`;
    
    summaryContent.innerHTML = `Server-Side Bulk Test Data Creation Failed:

Error: ${error.message}
Total Time: ${totalTime.toFixed(2)}s

Please check the server logs for more details.`;
    
    resultDiv.classList.remove('success', 'warning', 'error');
    resultDiv.classList.add('error');
    
    // Add to test history
    addToTestHistory({
      timestamp: Date.now(),
      method: 'POST',
      url: '/api_test/create_test_data',
      status: 'Error',
      responseTime: Math.round(totalTime * 1000),
      success: false
    });
  }
  
  button.textContent = originalText;
  
  // Auto-switch back to summary tab after completion
  setTimeout(() => {
    const summaryTab = resultDiv.querySelector('.tab:first-child');
    summaryTab.click();
  }, 2000);
}

async function testFollowEndpoint(method, url, index) {
  // Get the user ID from the input field
  const inputId = method === 'POST' ? `follow-user-id-${index}` : `unfollow-user-id-${index}`;
  const followedId = document.getElementById(inputId).value;
  
  if (!followedId || followedId < 1) {
    alert('Please enter a valid User ID');
    return;
  }
  
  const payload = { followed_id: parseInt(followedId) };
  
  // Call the regular testEndpoint function with our payload
  const startTime = performance.now();
  
  // Find result containers
  const resultDiv = document.getElementById(`result-${index}`);
  const summaryContent = resultDiv.querySelector(`#summary-${index} .content`);
  const requestContent = resultDiv.querySelector(`#request-${index} .content`);
  const responseContent = resultDiv.querySelector(`#response-${index} .content`);
  
  try {
    const options = {
      method: method,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify(payload)
    };
    
    // Show raw request
    let requestText = `${method} ${url} HTTP/1.1
Content-Type: application/json
Accept: application/json
Content-Length: ${options.body.length}

${options.body}`;
    
    requestContent.textContent = requestText;
    
    const response = await fetch(url, options);
    const endTime = performance.now();
    const responseTime = Math.round(endTime - startTime);
    
    let result = '';
    let rawResponseBody = '';
    const contentType = response.headers.get('content-type');
    
    if (contentType && contentType.includes('application/json')) {
      const data = await response.json();
      result = JSON.stringify(data, null, 2);
      rawResponseBody = result;
    } else {
      result = await response.text();
      rawResponseBody = result;
    }
    
    // Show raw response
    let responseText = `HTTP/1.1 ${response.status} ${response.statusText}`;
    for (const [key, value] of response.headers.entries()) {
      responseText += `\n${key}: ${value}`;
    }
    responseText += `\n\n${rawResponseBody}`;
    
    responseContent.textContent = responseText;
    
    // Add to test history
    addToTestHistory({
      timestamp: Date.now(),
      method: method,
      url: url,
      status: response.status,
      responseTime: responseTime,
      success: response.ok
    });
    
    // Display summary
    summaryContent.innerHTML = `Status: ${response.status} ${response.statusText}
Response Time: ${responseTime}ms
Content-Type: ${contentType}
User ID: ${followedId}

${result}`;
    
    resultDiv.classList.remove('hidden');
    resultDiv.classList.remove('success', 'error');
    resultDiv.classList.add(response.ok ? 'success' : 'error');
    
  } catch (error) {
    const endTime = performance.now();
    const responseTime = Math.round(endTime - startTime);
    
    // Show error in raw response
    responseContent.textContent = `Error: ${error.message}`;
    
    // Add error to test history
    addToTestHistory({
      timestamp: Date.now(),
      method: method,
      url: url,
      status: 'Error',
      responseTime: responseTime,
      success: false
    });
    
    // Display error summary
    summaryContent.innerHTML = `Error: ${error.message}
Response Time: ${responseTime}ms
User ID: ${followedId}`;
    
    resultDiv.classList.remove('hidden');
    resultDiv.classList.remove('success', 'error');
    resultDiv.classList.add('error');
  }
}

async function performanceFollowTest(method, url, index, iterations) {
  // Get the user ID from the input field
  const inputId = method === 'POST' ? `follow-user-id-${index}` : `unfollow-user-id-${index}`;
  const followedId = document.getElementById(inputId).value;
  
  if (!followedId || followedId < 1) {
    alert('Please enter a valid User ID');
    return;
  }
  
  const results = [];
  const button = document.querySelector(`#result-${index}`).closest('.endpoint').querySelector('button[onclick*="performanceFollowTest"]');
  const originalText = button.textContent;
  
  for (let i = 0; i < iterations; i++) {
    button.textContent = `Testing... (${i + 1}/${iterations})`;
    const startTime = performance.now();
    
    try {
      const payload = { followed_id: parseInt(followedId) };
      
      const options = {
        method: method,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify(payload)
      };
      
      const response = await fetch(url, options);
      const endTime = performance.now();
      const responseTime = Math.round(endTime - startTime);
      
      results.push({
        iteration: i + 1,
        status: response.status,
        responseTime: responseTime,
        success: response.ok
      });
      
      // Add each test to history
      addToTestHistory({
        timestamp: Date.now(),
        method: method,
        url: url,
        status: response.status,
        responseTime: responseTime,
        success: response.ok
      });
      
    } catch (error) {
      const endTime = performance.now();
      const responseTime = Math.round(endTime - startTime);
      
      results.push({
        iteration: i + 1,
        status: 'Error',
        responseTime: responseTime,
        success: false,
        error: error.message
      });
      
      // Add error to history
      addToTestHistory({
        timestamp: Date.now(),
        method: method,
        url: url,
        status: 'Error',
        responseTime: responseTime,
        success: false
      });
    }
  }
  
  button.textContent = originalText;
  
  // Calculate performance metrics
  const successfulResults = results.filter(r => r.success);
  const avgResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / results.length;
  const minResponseTime = Math.min(...results.map(r => r.responseTime));
  const maxResponseTime = Math.max(...results.map(r => r.responseTime));
  const successRate = (successfulResults.length / results.length) * 100;
  
  // Display performance results
  const resultDiv = document.getElementById(`result-${index}`);
  const resultContent = resultDiv.querySelector(`#summary-${index} .content`);
  
  resultContent.innerHTML = `Follow Performance Test Results (${iterations} iterations):
User ID: ${followedId}

Success Rate: ${successRate.toFixed(1)}%
Average Response Time: ${Math.round(avgResponseTime)}ms
Min Response Time: ${minResponseTime}ms
Max Response Time: ${maxResponseTime}ms

Individual Results:
${results.map(r => `#${r.iteration}: ${r.status} - ${r.responseTime}ms${r.error ? ` (${r.error})` : ''}`).join('\n')}`;
  
  resultDiv.classList.remove('hidden');
  resultDiv.classList.remove('success', 'warning', 'error');
  resultDiv.classList.add(successRate > 90 ? 'success' : 'warning');
}

async function testFollowingEndpoint(method, url, index) {
  // Get the following ID from the input field
  const followingId = document.getElementById(`following-id-${index}`).value;
  
  if (!followingId || followingId < 1) {
    alert('Please enter a valid Following ID');
    return;
  }
  
  // Update the URL with the following ID
  const actualUrl = url.replace(/\/\d+$/, `/${followingId}`);
  
  // Call the regular testEndpoint function with DELETE method and no payload
  const startTime = performance.now();
  
  // Find result containers
  const resultDiv = document.getElementById(`result-${index}`);
  const summaryContent = resultDiv.querySelector(`#summary-${index} .content`);
  const requestContent = resultDiv.querySelector(`#request-${index} .content`);
  const responseContent = resultDiv.querySelector(`#response-${index} .content`);
  
  try {
    const options = {
      method: method,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    };
    
    // Show raw request
    let requestText = `${method} ${actualUrl} HTTP/1.1
Content-Type: application/json
Accept: application/json`;
    
    requestContent.textContent = requestText;
    
    const response = await fetch(actualUrl, options);
    const endTime = performance.now();
    const responseTime = Math.round(endTime - startTime);
    
    let result = '';
    let rawResponseBody = '';
    const contentType = response.headers.get('content-type');
    
    if (contentType && contentType.includes('application/json')) {
      const data = await response.json();
      result = JSON.stringify(data, null, 2);
      rawResponseBody = result;
    } else {
      result = await response.text();
      rawResponseBody = result;
    }
    
    // Show raw response
    let responseText = `HTTP/1.1 ${response.status} ${response.statusText}`;
    for (const [key, value] of response.headers.entries()) {
      responseText += `\n${key}: ${value}`;
    }
    responseText += `\n\n${rawResponseBody}`;
    
    responseContent.textContent = responseText;
    
    // Add to test history
    addToTestHistory({
      timestamp: Date.now(),
      method: method,
      url: actualUrl,
      status: response.status,
      responseTime: responseTime,
      success: response.ok
    });
    
    // Display summary
    summaryContent.innerHTML = `Status: ${response.status} ${response.statusText}
Response Time: ${responseTime}ms
Content-Type: ${contentType}
Following ID: ${followingId}

${result}`;
    
    resultDiv.classList.remove('hidden');
    resultDiv.classList.remove('success', 'error');
    resultDiv.classList.add(response.ok ? 'success' : 'error');
    
  } catch (error) {
    const endTime = performance.now();
    const responseTime = Math.round(endTime - startTime);
    
    // Show error in raw response
    responseContent.textContent = `Error: ${error.message}`;
    
    // Add error to test history
    addToTestHistory({
      timestamp: Date.now(),
      method: method,
      url: actualUrl,
      status: 'Error',
      responseTime: responseTime,
      success: false
    });
    
    // Display error summary
    summaryContent.innerHTML = `Error: ${error.message}
Response Time: ${responseTime}ms
Following ID: ${followingId}`;
    
    resultDiv.classList.remove('hidden');
    resultDiv.classList.remove('success', 'error');
    resultDiv.classList.add('error');
  }
}

async function performanceFollowingTest(method, url, index, iterations) {
  // Get the following ID from the input field
  const followingId = document.getElementById(`following-id-${index}`).value;
  
  if (!followingId || followingId < 1) {
    alert('Please enter a valid Following ID');
    return;
  }
  
  // Update the URL with the following ID
  const actualUrl = url.replace(/\/\d+$/, `/${followingId}`);
  
  const results = [];
  const button = document.querySelector(`#result-${index}`).closest('.endpoint').querySelector('button[onclick*="performanceFollowingTest"]');
  const originalText = button.textContent;
  
  for (let i = 0; i < iterations; i++) {
    button.textContent = `Testing... (${i + 1}/${iterations})`;
    const startTime = performance.now();
    
    try {
      const options = {
        method: method,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        }
      };
      
      const response = await fetch(actualUrl, options);
      const endTime = performance.now();
      const responseTime = Math.round(endTime - startTime);
      
      results.push({
        iteration: i + 1,
        status: response.status,
        responseTime: responseTime,
        success: response.ok
      });
      
      // Add each test to history
      addToTestHistory({
        timestamp: Date.now(),
        method: method,
        url: actualUrl,
        status: response.status,
        responseTime: responseTime,
        success: response.ok
      });
      
    } catch (error) {
      const endTime = performance.now();
      const responseTime = Math.round(endTime - startTime);
      
      results.push({
        iteration: i + 1,
        status: 'Error',
        responseTime: responseTime,
        success: false,
        error: error.message
      });
      
      // Add error to history
      addToTestHistory({
        timestamp: Date.now(),
        method: method,
        url: actualUrl,
        status: 'Error',
        responseTime: responseTime,
        success: false
      });
    }
  }
  
  button.textContent = originalText;
  
  // Calculate performance metrics
  const successfulResults = results.filter(r => r.success);
  const avgResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / results.length;
  const minResponseTime = Math.min(...results.map(r => r.responseTime));
  const maxResponseTime = Math.max(...results.map(r => r.responseTime));
  const successRate = (successfulResults.length / results.length) * 100;
  
  // Display performance results
  const resultDiv = document.getElementById(`result-${index}`);
  const resultContent = resultDiv.querySelector(`#summary-${index} .content`);
  
  resultContent.innerHTML = `Following Performance Test Results (${iterations} iterations):
Following ID: ${followingId}

Success Rate: ${successRate.toFixed(1)}%
Average Response Time: ${Math.round(avgResponseTime)}ms
Min Response Time: ${minResponseTime}ms
Max Response Time: ${maxResponseTime}ms

Individual Results:
${results.map(r => `#${r.iteration}: ${r.status} - ${r.responseTime}ms${r.error ? ` (${r.error})` : ''}`).join('\n')}`;
  
  resultDiv.classList.remove('hidden');
  resultDiv.classList.remove('success', 'warning', 'error');
  resultDiv.classList.add(successRate > 90 ? 'success' : 'warning');
}

async function createSingleRecord(method, url, payload, identifier, userId = null) {
  const startTime = performance.now();
  
  try {
    const testPayload = JSON.parse(JSON.stringify(payload));
    
    // Generate unique names for users
    if (testPayload.user && testPayload.user.name) {
      testPayload.user.name = `${testPayload.user.name} ${identifier}`;
    }
    
    // Generate random sleep times
    if (testPayload.sleep) {
      const daysAgo = Math.floor(Math.random() * 365);
      const randomDate = new Date();
      randomDate.setDate(randomDate.getDate() - daysAgo);
      
      const startHour = 21 + Math.floor(Math.random() * 4);
      const startMinute = Math.floor(Math.random() * 60);
      const startDate = new Date(randomDate);
      startDate.setHours(startHour, startMinute, 0, 0);
      
      const sleepDurationHours = 6 + Math.floor(Math.random() * 4);
      const sleepDurationMinutes = Math.floor(Math.random() * 60);
      const endDate = new Date(startDate);
      endDate.setHours(endDate.getHours() + sleepDurationHours, endDate.getMinutes() + sleepDurationMinutes);
      
      const formatDate = (date) => {
        return date.getFullYear() + '-' + 
               String(date.getMonth() + 1).padStart(2, '0') + '-' + 
               String(date.getDate()).padStart(2, '0') + ' ' +
               String(date.getHours()).padStart(2, '0') + ':' +
               String(date.getMinutes()).padStart(2, '0') + ':00 PST';
      };
      
      testPayload.sleep.started_at_raw = formatDate(startDate);
      testPayload.sleep.stopped_at_raw = formatDate(endDate);
    }
    
    const options = {
      method: method,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify(testPayload)
    };
    
    // Set user context for sleep records if needed
    if (userId && testPayload.sleep) {
      document.cookie = `user_id=${userId}; path=/`;
    }
    
    const response = await fetch(url, options);
    const endTime = performance.now();
    const responseTime = Math.round(endTime - startTime);
    
    let userIdExtracted = null;
    if (response.ok && testPayload.user) {
      try {
        const responseData = await response.json();
        userIdExtracted = responseData.id;
      } catch (e) {
        // Ignore JSON parsing errors
      }
    }
    
    return {
      success: response.ok,
      status: response.status,
      responseTime: responseTime,
      userId: userIdExtracted,
      identifier: identifier
    };
    
  } catch (error) {
    const endTime = performance.now();
    const responseTime = Math.round(endTime - startTime);
    
    return {
      success: false,
      status: 'Error',
      responseTime: responseTime,
      error: error.message,
      identifier: identifier
    };
  }
}
</script>

<style>
* { box-sizing: border-box; }
body { margin: 0; padding: 16px; font-family: system-ui, sans-serif; font-size: 14px; line-height: 1.4; }

.container { max-width: 1200px; margin: 0 auto; }
h1 { margin: 0 0 24px 0; font-size: 24px; }
h2 { margin: 16px 0 8px 0; font-size: 16px; }

.section { margin: 16px 0; padding: 12px; border: 1px solid #ddd; border-radius: 4px; }
.stats { display: flex; gap: 16px; flex-wrap: wrap; }
.stats span { font-size: 13px; }

.endpoint { margin: 16px 0; padding: 12px; border: 1px solid #ddd; border-radius: 4px; }
.endpoint-header { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
.method { font-weight: bold; font-size: 12px; color: #333; background: #f5f5f5; padding: 2px 6px; border-radius: 3px; }
.url { font-family: monospace; font-size: 12px; color: #666; }
.desc { font-size: 12px; color: #888; }

.payload { margin: 8px 0; }
.payload summary { font-size: 12px; cursor: pointer; }
.payload pre { font-size: 11px; margin: 4px 0; padding: 8px; background: #f9f9f9; border-radius: 3px; overflow-x: auto; }

.actions { margin: 8px 0; }
.actions button { padding: 6px 12px; margin-right: 8px; font-size: 12px; border: 1px solid #ddd; background: #f9f9f9; border-radius: 3px; cursor: pointer; }
.actions button:hover { background: #f0f0f0; }

form { display: flex; gap: 8px; align-items: center; margin: 8px 0; }
form label { font-size: 12px; }
form input { padding: 4px 6px; font-size: 12px; border: 1px solid #ddd; border-radius: 3px; }
form input[type="submit"], form input[type="submit"], button { padding: 4px 8px; font-size: 12px; border: 1px solid #ddd; background: #f9f9f9; border-radius: 3px; cursor: pointer; }

.result { margin-top: 8px; padding: 8px; border: 1px solid #ddd; border-radius: 3px; }
.result.success { background: #f0f9f0; border-color: #90ee90; }
.result.error { background: #fdf0f0; border-color: #ffb3b3; }
.result.warning { background: #fffdf0; border-color: #ffd700; }

.tabs { display: flex; margin-bottom: 8px; }
.tab { padding: 4px 8px; font-size: 11px; border: 1px solid #ddd; background: #f9f9f9; cursor: pointer; border-right: none; }
.tab:first-child { border-radius: 3px 0 0 0; }
.tab:last-child { border-radius: 0 3px 0 0; border-right: 1px solid #ddd; }
.tab.active { background: white; font-weight: bold; }

.tab-content { display: none; }
.tab-content.active { display: block; }
.content { font-size: 11px; font-family: monospace; white-space: pre-wrap; overflow-x: auto; line-height: 1.3; }

.hidden { display: none; }

#auth-status { margin: 8px 0; padding: 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 12px; }
#auth-status.success { background: #f0f9f0; border-color: #90ee90; }
#auth-status.warning { background: #fffdf0; border-color: #ffd700; }

.user-details { margin-top: 4px; font-size: 11px; }
.user-details p { margin: 2px 0; }

.test-item { display: flex; gap: 12px; padding: 4px 8px; margin: 2px 0; border-radius: 2px; font-size: 11px; align-items: center; }
.test-item.success { background: #f0f9f0; }
.test-item.error { background: #fdf0f0; }
.test-time { min-width: 60px; color: #666; }
.test-method { min-width: 40px; font-weight: bold; font-family: monospace; }
.test-url { flex-grow: 1; font-family: monospace; color: #666; }
.test-status { min-width: 40px; font-weight: bold; }
.test-time-taken { min-width: 50px; font-family: monospace; text-align: right; }

.auth-required, .no-auth { 
  padding: 2px 6px; 
  border-radius: 3px; 
  font-size: 10px; 
  font-weight: bold; 
  margin-left: 8px; 
}
.auth-required { 
  background-color: #ffeaa7; 
  color: #d63031; 
}
.no-auth { 
  background-color: #74b9ff; 
  color: white; 
}

.description {
  margin: 16px 0 24px 0;
  padding: 16px;
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 4px;
}

.description p {
  margin: 0 0 12px 0;
  font-size: 14px;
  color: #495057;
}

.description ol {
  margin: 0;
  padding-left: 20px;
}

.description li {
  margin: 8px 0;
  font-size: 13px;
  line-height: 1.5;
  color: #6c757d;
}

.description strong {
  color: #343a40;
  font-weight: 600;
}

.test-data-form {
  margin-bottom: 16px;
}

.form-row {
  display: flex;
  gap: 16px;
  align-items: center;
  margin-bottom: 12px;
  flex-wrap: wrap;
}

.form-row label {
  font-size: 12px;
  font-weight: 500;
  min-width: 120px;
}

.form-row input[type="number"] {
  padding: 6px 8px;
  font-size: 12px;
  border: 1px solid #ddd;
  border-radius: 3px;
  width: 100px;
}

.bulk-create-btn {
  padding: 8px 16px;
  font-size: 13px;
  font-weight: 500;
  background: #007bff;
  color: white;
  border: 1px solid #007bff;
  border-radius: 4px;
  cursor: pointer;
}

.bulk-create-btn:hover {
  background: #0056b3;
  border-color: #0056b3;
}
</style>
