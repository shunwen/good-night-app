<% content_for :title, "API Test" %>

<div class="container">
  <h1>API Test</h1>

  <div class="section">
    <h2>Auth</h2>
    <div id="auth-status">
      <%= render partial: "auth_status", locals: { user: nil, user_id: nil, sleeps_count: 0, following_count: 0, status: :cleared } %>
    </div>
    <%= form_with url: api_test_impersonate_path, method: :post, local: false do |form| %>
      <%= form.label :user_id, "User ID:" %>
      <%= form.number_field :user_id, value: 1, min: 1 %>
      <%= form.submit "Impersonate" %>
    <% end %>
    <%= button_to "Clear", api_test_clear_auth_path, method: :delete, form: { local: false } %>
  </div>

  <div class="section">
    <h2>Test History</h2>
    <div id="test-history">
      <p>No tests run yet</p>
    </div>
  </div>

  <%= render 'endpoints' %>
</div>

<script>
let testHistory = [];

// Hotwire handles the impersonation now

function showTab(button, tabId) {
  // Get the parent result container
  const resultContainer = button.closest('.result');
  
  // Hide all tab contents and remove active from buttons
  const allTabs = resultContainer.querySelectorAll('.tab-content');
  const allButtons = resultContainer.querySelectorAll('.tab');
  
  allTabs.forEach(tab => tab.classList.remove('active'));
  allButtons.forEach(btn => btn.classList.remove('active'));
  
  // Show selected tab and mark button as active
  document.getElementById(tabId).classList.add('active');
  button.classList.add('active');
}

function addToTestHistory(test) {
  testHistory.unshift(test); // Add to beginning of array
  if (testHistory.length > 20) {
    testHistory = testHistory.slice(0, 20); // Keep only last 20 tests
  }
  updateTestHistoryDisplay();
}

function updateTestHistoryDisplay() {
  const historyDiv = document.getElementById('test-history');
  
  if (testHistory.length === 0) {
    historyDiv.innerHTML = '<p>No tests run yet</p>';
    return;
  }
  
  const historyHtml = testHistory.map(test => {
    const statusClass = test.success ? 'success' : 'error';
    const timeStr = new Date(test.timestamp).toLocaleTimeString();
    return `<div class="test-item ${statusClass}">
      <span class="test-time">${timeStr}</span>
      <span class="test-method">${test.method}</span>
      <span class="test-url">${test.url}</span>
      <span class="test-status">${test.status}</span>
      <span class="test-time-taken">${test.responseTime}ms</span>
    </div>`;
  }).join('');
  
  historyDiv.innerHTML = historyHtml;
}

async function testEndpoint(method, url, payload) {
  const startTime = performance.now();
  
  // Find result containers
  const resultDiv = document.querySelector(`button[onclick*="${method}"][onclick*="${url}"]`).closest('.endpoint').querySelector('.result');
  const summaryContent = resultDiv.querySelector('#summary-' + resultDiv.id.split('-')[1] + ' .content');
  const requestContent = resultDiv.querySelector('#request-' + resultDiv.id.split('-')[1] + ' .content');
  const responseContent = resultDiv.querySelector('#response-' + resultDiv.id.split('-')[1] + ' .content');
  
  try {
    const options = {
      method: method,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
      }
    };
    
    if (payload && (method === 'POST' || method === 'PATCH')) {
      const testPayload = JSON.parse(JSON.stringify(payload)); // Deep copy
      
      // Generate unique user name for create operations
      if (testPayload.user && testPayload.user.name) {
        const randomSuffix = Math.random().toString(36).substring(2, 8);
        testPayload.user.name = `Test User ${randomSuffix}`; // Always use base name
      }
      
      // Generate random date within past year for sleep records
      if (testPayload.sleep && testPayload.sleep.started_at_raw) {
        const daysAgo = Math.floor(Math.random() * 365); // Random day in past year
        const randomDate = new Date();
        randomDate.setDate(randomDate.getDate() - daysAgo);
        
        // Random sleep start time between 9 PM and 1 AM
        const startHour = 21 + Math.floor(Math.random() * 4); // 21, 22, 23, or 0 (midnight)
        const startMinute = Math.floor(Math.random() * 60);
        
        const startDate = new Date(randomDate);
        startDate.setHours(startHour, startMinute, 0, 0);
        
        // Sleep duration between 6-10 hours
        const sleepDurationHours = 6 + Math.floor(Math.random() * 4);
        const sleepDurationMinutes = Math.floor(Math.random() * 60);
        
        const endDate = new Date(startDate);
        endDate.setHours(endDate.getHours() + sleepDurationHours, endDate.getMinutes() + sleepDurationMinutes);
        
        // Format dates as strings
        const formatDate = (date) => {
          return date.getFullYear() + '-' + 
                 String(date.getMonth() + 1).padStart(2, '0') + '-' + 
                 String(date.getDate()).padStart(2, '0') + ' ' +
                 String(date.getHours()).padStart(2, '0') + ':' +
                 String(date.getMinutes()).padStart(2, '0') + ':00 PST';
        };
        
        testPayload.sleep.started_at_raw = formatDate(startDate);
        testPayload.sleep.stopped_at_raw = formatDate(endDate);
      }
      
      options.body = JSON.stringify(testPayload);
    }
    
    // Show raw request
    let requestText = `${method} ${url} HTTP/1.1
Content-Type: application/json
Accept: application/json
X-CSRF-Token: ${document.querySelector('meta[name="csrf-token"]').getAttribute('content')}`;
    
    if (options.body) {
      requestText += `\nContent-Length: ${options.body.length}\n\n${options.body}`;
    }
    
    requestContent.textContent = requestText;
    
    const response = await fetch(url, options);
    const endTime = performance.now();
    const responseTime = Math.round(endTime - startTime);
    
    let result = '';
    let rawResponseBody = '';
    const contentType = response.headers.get('content-type');
    
    if (contentType && contentType.includes('application/json')) {
      const data = await response.json();
      result = JSON.stringify(data, null, 2);
      rawResponseBody = result;
    } else {
      result = await response.text();
      rawResponseBody = result;
    }
    
    // Show raw response
    let responseText = `HTTP/1.1 ${response.status} ${response.statusText}`;
    for (const [key, value] of response.headers.entries()) {
      responseText += `\n${key}: ${value}`;
    }
    responseText += `\n\n${rawResponseBody}`;
    
    responseContent.textContent = responseText;
    
    // Add to test history
    addToTestHistory({
      timestamp: Date.now(),
      method: method,
      url: url,
      status: response.status,
      responseTime: responseTime,
      success: response.ok
    });
    
    // Display summary
    summaryContent.innerHTML = `Status: ${response.status} ${response.statusText}
Response Time: ${responseTime}ms
Content-Type: ${contentType}

${result}`;
    
    resultDiv.classList.remove('hidden');
    resultDiv.classList.remove('success', 'error');
    resultDiv.classList.add(response.ok ? 'success' : 'error');
    
  } catch (error) {
    const endTime = performance.now();
    const responseTime = Math.round(endTime - startTime);
    
    // Show error in raw response
    responseContent.textContent = `Error: ${error.message}`;
    
    // Add error to test history
    addToTestHistory({
      timestamp: Date.now(),
      method: method,
      url: url,
      status: 'Error',
      responseTime: responseTime,
      success: false
    });
    
    // Display error summary
    summaryContent.innerHTML = `Error: ${error.message}
Response Time: ${responseTime}ms`;
    
    resultDiv.classList.remove('hidden');
    resultDiv.classList.remove('success', 'error');
    resultDiv.classList.add('error');
  }
}

async function performanceTest(method, url, payload, iterations) {
  const results = [];
  const button = document.querySelector(`button[onclick*="performanceTest"][onclick*="${method}"][onclick*="${url}"]`);
  const originalText = button.textContent;
  
  for (let i = 0; i < iterations; i++) {
    button.textContent = `Testing... (${i + 1}/${iterations})`;
    const startTime = performance.now();
    
    try {
      const options = {
        method: method,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
        }
      };
      
      if (payload && (method === 'POST' || method === 'PATCH')) {
        // Add randomization for create operations to avoid conflicts
        if (payload.user && payload.user.name) {
          const testPayload = JSON.parse(JSON.stringify(payload)); // Deep copy
          const randomSuffix = Math.random().toString(36).substring(2, 8);
          testPayload.user.name = `Test User ${randomSuffix}`; // Always use base name
          options.body = JSON.stringify(testPayload);
        } else {
          options.body = JSON.stringify(payload);
        }
      }
      
      const response = await fetch(url, options);
      const endTime = performance.now();
      const responseTime = Math.round(endTime - startTime);
      
      results.push({
        iteration: i + 1,
        status: response.status,
        responseTime: responseTime,
        success: response.ok
      });
      
      // Add each test to history
      addToTestHistory({
        timestamp: Date.now(),
        method: method,
        url: url,
        status: response.status,
        responseTime: responseTime,
        success: response.ok
      });
      
    } catch (error) {
      const endTime = performance.now();
      const responseTime = Math.round(endTime - startTime);
      
      results.push({
        iteration: i + 1,
        status: 'Error',
        responseTime: responseTime,
        success: false,
        error: error.message
      });
      
      // Add error to history
      addToTestHistory({
        timestamp: Date.now(),
        method: method,
        url: url,
        status: 'Error',
        responseTime: responseTime,
        success: false
      });
    }
  }
  
  button.textContent = originalText;
  
  // Calculate performance metrics
  const successfulResults = results.filter(r => r.success);
  const avgResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / results.length;
  const minResponseTime = Math.min(...results.map(r => r.responseTime));
  const maxResponseTime = Math.max(...results.map(r => r.responseTime));
  const successRate = (successfulResults.length / results.length) * 100;
  
  // Display performance results
  const resultDiv = button.closest('.endpoint').querySelector('.result');
  const resultContent = resultDiv.querySelector('#summary-' + resultDiv.id.split('-')[1] + ' .content');
  
  resultContent.innerHTML = `Performance Test Results (${iterations} iterations):

Success Rate: ${successRate.toFixed(1)}%
Average Response Time: ${Math.round(avgResponseTime)}ms
Min Response Time: ${minResponseTime}ms
Max Response Time: ${maxResponseTime}ms

Individual Results:
${results.map(r => `#${r.iteration}: ${r.status} - ${r.responseTime}ms${r.error ? ` (${r.error})` : ''}`).join('\n')}`;
  
  resultDiv.classList.remove('hidden');
  resultDiv.classList.remove('success', 'warning', 'error');
  resultDiv.classList.add(successRate > 90 ? 'success' : 'warning');
}

async function createTestData(method, url, payload, count) {
  const results = [];
  const button = document.querySelector(`button[onclick*="createTestData"][onclick*="${method}"][onclick*="${url}"]`);
  const originalText = button.textContent;
  
  for (let i = 0; i < count; i++) {
    button.textContent = `Creating... (${i + 1}/${count})`;
    const startTime = performance.now();
    
    try {
      const options = {
        method: method,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
        }
      };
      
      if (payload && (method === 'POST' || method === 'PATCH')) {
        const testPayload = JSON.parse(JSON.stringify(payload)); // Deep copy
        
        // Generate random date within past year for sleep records
        if (testPayload.sleep && testPayload.sleep.started_at_raw) {
          const daysAgo = Math.floor(Math.random() * 365); // Random day in past year
          const randomDate = new Date();
          randomDate.setDate(randomDate.getDate() - daysAgo);
          
          // Random sleep start time between 9 PM and 1 AM
          const startHour = 21 + Math.floor(Math.random() * 4); // 21, 22, 23, or 0 (midnight)
          const startMinute = Math.floor(Math.random() * 60);
          
          const startDate = new Date(randomDate);
          startDate.setHours(startHour, startMinute, 0, 0);
          
          // Sleep duration between 6-10 hours
          const sleepDurationHours = 6 + Math.floor(Math.random() * 4);
          const sleepDurationMinutes = Math.floor(Math.random() * 60);
          
          const endDate = new Date(startDate);
          endDate.setHours(endDate.getHours() + sleepDurationHours, endDate.getMinutes() + sleepDurationMinutes);
          
          // Format dates as strings
          const formatDate = (date) => {
            return date.getFullYear() + '-' + 
                   String(date.getMonth() + 1).padStart(2, '0') + '-' + 
                   String(date.getDate()).padStart(2, '0') + ' ' +
                   String(date.getHours()).padStart(2, '0') + ':' +
                   String(date.getMinutes()).padStart(2, '0') + ':00 PST';
          };
          
          testPayload.sleep.started_at_raw = formatDate(startDate);
          testPayload.sleep.stopped_at_raw = formatDate(endDate);
        }
        
        options.body = JSON.stringify(testPayload);
      }
      
      const response = await fetch(url, options);
      const endTime = performance.now();
      const responseTime = Math.round(endTime - startTime);
      
      results.push({
        iteration: i + 1,
        status: response.status,
        responseTime: responseTime,
        success: response.ok
      });
      
      // Add each test to history (but only every 10th to avoid flooding)
      if (i % 10 === 0 || i === count - 1) {
        addToTestHistory({
          timestamp: Date.now(),
          method: method,
          url: url,
          status: response.status,
          responseTime: responseTime,
          success: response.ok
        });
      }
      
    } catch (error) {
      const endTime = performance.now();
      const responseTime = Math.round(endTime - startTime);
      
      results.push({
        iteration: i + 1,
        status: 'Error',
        responseTime: responseTime,
        success: false,
        error: error.message
      });
    }
  }
  
  button.textContent = originalText;
  
  // Calculate summary metrics
  const successfulResults = results.filter(r => r.success);
  const avgResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / results.length;
  const successRate = (successfulResults.length / results.length) * 100;
  
  // Display test data creation results
  const resultDiv = button.closest('.endpoint').querySelector('.result');
  const resultContent = resultDiv.querySelector('#summary-' + resultDiv.id.split('-')[1] + ' .content');
  
  resultContent.innerHTML = `Test Data Generation Complete (${count} records):

Success Rate: ${successRate.toFixed(1)}%
Average Response Time: ${Math.round(avgResponseTime)}ms
Records Created: ${successfulResults.length}
Failed: ${results.length - successfulResults.length}

Generated sleep records spanning the past year with random:
- Sleep start times (9 PM - 1 AM)
- Sleep durations (6-10 hours)
- Dates throughout the past 365 days`;
  
  resultDiv.classList.remove('hidden');
  resultDiv.classList.remove('success', 'warning', 'error');
  resultDiv.classList.add(successRate > 90 ? 'success' : 'warning');
}
</script>

<style>
* { box-sizing: border-box; }
body { margin: 0; padding: 16px; font-family: system-ui, sans-serif; font-size: 14px; line-height: 1.4; }

.container { max-width: 1200px; margin: 0 auto; }
h1 { margin: 0 0 24px 0; font-size: 24px; }
h2 { margin: 16px 0 8px 0; font-size: 16px; }

.section { margin: 16px 0; padding: 12px; border: 1px solid #ddd; border-radius: 4px; }
.stats { display: flex; gap: 16px; flex-wrap: wrap; }
.stats span { font-size: 13px; }

.endpoint { margin: 16px 0; padding: 12px; border: 1px solid #ddd; border-radius: 4px; }
.endpoint-header { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
.method { font-weight: bold; font-size: 12px; color: #333; background: #f5f5f5; padding: 2px 6px; border-radius: 3px; }
.url { font-family: monospace; font-size: 12px; color: #666; }
.desc { font-size: 12px; color: #888; }

.payload { margin: 8px 0; }
.payload summary { font-size: 12px; cursor: pointer; }
.payload pre { font-size: 11px; margin: 4px 0; padding: 8px; background: #f9f9f9; border-radius: 3px; overflow-x: auto; }

.actions { margin: 8px 0; }
.actions button { padding: 6px 12px; margin-right: 8px; font-size: 12px; border: 1px solid #ddd; background: #f9f9f9; border-radius: 3px; cursor: pointer; }
.actions button:hover { background: #f0f0f0; }

form { display: flex; gap: 8px; align-items: center; margin: 8px 0; }
form label { font-size: 12px; }
form input { padding: 4px 6px; font-size: 12px; border: 1px solid #ddd; border-radius: 3px; }
form input[type="submit"], form input[type="submit"], button { padding: 4px 8px; font-size: 12px; border: 1px solid #ddd; background: #f9f9f9; border-radius: 3px; cursor: pointer; }

.result { margin-top: 8px; padding: 8px; border: 1px solid #ddd; border-radius: 3px; }
.result.success { background: #f0f9f0; border-color: #90ee90; }
.result.error { background: #fdf0f0; border-color: #ffb3b3; }
.result.warning { background: #fffdf0; border-color: #ffd700; }

.tabs { display: flex; margin-bottom: 8px; }
.tab { padding: 4px 8px; font-size: 11px; border: 1px solid #ddd; background: #f9f9f9; cursor: pointer; border-right: none; }
.tab:first-child { border-radius: 3px 0 0 0; }
.tab:last-child { border-radius: 0 3px 0 0; border-right: 1px solid #ddd; }
.tab.active { background: white; font-weight: bold; }

.tab-content { display: none; }
.tab-content.active { display: block; }
.content { font-size: 11px; font-family: monospace; white-space: pre-wrap; overflow-x: auto; line-height: 1.3; }

.hidden { display: none; }

#auth-status { margin: 8px 0; padding: 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 12px; }
#auth-status.success { background: #f0f9f0; border-color: #90ee90; }
#auth-status.warning { background: #fffdf0; border-color: #ffd700; }

.user-details { margin-top: 4px; font-size: 11px; }
.user-details p { margin: 2px 0; }

.test-item { display: flex; gap: 12px; padding: 4px 8px; margin: 2px 0; border-radius: 2px; font-size: 11px; align-items: center; }
.test-item.success { background: #f0f9f0; }
.test-item.error { background: #fdf0f0; }
.test-time { min-width: 60px; color: #666; }
.test-method { min-width: 40px; font-weight: bold; font-family: monospace; }
.test-url { flex-grow: 1; font-family: monospace; color: #666; }
.test-status { min-width: 40px; font-weight: bold; }
.test-time-taken { min-width: 50px; font-family: monospace; text-align: right; }

.auth-required, .no-auth { 
  padding: 2px 6px; 
  border-radius: 3px; 
  font-size: 10px; 
  font-weight: bold; 
  margin-left: 8px; 
}
.auth-required { 
  background-color: #ffeaa7; 
  color: #d63031; 
}
.no-auth { 
  background-color: #74b9ff; 
  color: white; 
}
</style>